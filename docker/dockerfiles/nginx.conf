worker_processes  auto;
error_log error.log;

env REDIS_HOST;
env REDIS_PORT;
events {
    worker_connections 1024;
}
http {
    init_worker_by_lua_block {
        local uuid = require 'resty.jit-uuid'
        uuid.seed()
    }
    resolver 127.0.0.11 ipv6=off;

    server {
        listen        8000;
        charset       utf-8;
        charset_types application/json;
        default_type  application/json;


        lua_code_cache on;
        real_ip_header X-Forwarded-For;
        # set_real_ip_from 0.0.0.0/0;

        location / {
            if ($request_method ~* "(GET|POST)") {
                add_header "Access-Control-Allow-Origin"  *;
            }

            if ($request_method = OPTIONS ) {
                add_header "Access-Control-Allow-Origin"  *;
                add_header "Access-Control-Allow-Methods" "GET, POST, OPTIONS, HEAD";
                add_header "Access-Control-Allow-Headers" "Authorization, Origin, X-Requested-With, Content-Type, Accept";
                return 200;
            }

            content_by_lua '
                local uuid = require "resty.jit-uuid"
                local cjson = require "cjson"
                local redis = require "resty.redis"
                local r     = redis:new()
                local ok, err = r:connect(os.getenv("REDIS_HOST"), os.getenv("REDIS_PORT"))

                if not ok then
                  ngx.say(cjson.encode({
                    status = "error", 
                    msg =  "failed to connect: " .. err
                    }
                   )
                  )
                  return
                end

                local payload = {}

                local req = {}
                req["ip"] = ngx.var.remote_addr
                req["user_agent"] = ngx.var.http_user_agent
                req["referer"] = ngx.var.http_referer
                req["x_forwarded_for"] = ngx.var.http_x_forwarded_for
                
                local get, post, files = require "resty.reqargs"()
                if ngx.var.request_uri:sub(-6) == "events" then
                  payload["class"] = "HitJob"
                else
                  payload["class"] = "SessionJob"
                end
                payload["queue"] = "default"
                payload["jid"] = uuid()
                payload["args"] = {post, req}
                payload["retry"] = true
                payload["created_at"] = os.time()
                payload["enqueued_at"] = os.time()

                assert(r:lpush("queue:default", cjson.encode(payload)))
                r:set_keepalive()
                r = nil
                ngx.status  = ngx.HTTP_OK
                ngx.say(cjson.encode({status = "saved", msg=payload}))
                return ngx.exit(ngx.HTTP_OK)
            ';
        }
    }
}